<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link rel="stylesheet" type="text/css" href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2"/>


    <meta name="description" content="No King rules forervr" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />


<meta name="description" content="No King rules forervr">
<meta property="og:type" content="website">
<meta property="og:title" content="Muffin">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Muffin">
<meta property="og:description" content="No King rules forervr">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Muffin">
<meta name="twitter:description" content="No King rules forervr">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'always'
  };
</script>



  <title> Muffin </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?8f0ae52cb7e0a2bcfd057ac455fc3c2c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Muffin</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
    <div class="site-search">
      
  
  <form class="site-search-form">
    <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
  </form>


<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'x-qRhLCZZSH2skgHyC3F','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
          <article id="post-一些网络协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/18/一些网络协议/" class="article-date">
  <time datetime="2018-07-18T07:23:25.000Z" itemprop="datePublished">2018-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/18/一些网络协议/">一些网络协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ARP（地址解析协议）"><a href="#ARP（地址解析协议）" class="headerlink" title="ARP（地址解析协议）"></a>ARP（地址解析协议）</h1><p>基本功能为透过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。在每台安装有TCP/IP协议的电脑或路由器里都有一个ARP缓存表，表里的IP地址与MAC地址是一对应的。</p>
<p>当发送数据时，主机A会在自己的ARP缓存表中寻找是否有目标IP地址。如果找到就知道目标MAC地址为（00-BB-00-62-C2-02），直接把目标MAC地址写入帧里面发送就可；如果在ARP缓存表中没有找到相对应的IP地址，主机A就会在网络上发送一个 广播（ARP request），目标MAC地址是“FF.FF.FF.FF.FF.FF”，这表示向同一网段内的所有主机发出这样的询问：“192.168.38.11的MAC地址是什么？”网络上其他主机并不响应ARP询问，只有主机B接收到这个帧时，才向主机A做出这样的回应（ARP response）：“192.168.38.11的MAC地址是（00-BB-00-62-C2-02）”。这样，主机A就知道主机B的MAC地址，它就可以向主机B发送信息。同时它还更新自己的ARP缓存表，下次再向主机B发送信息时，直接从ARP缓存表里查找就可。ARP缓存表采用老化机制，在一段时间内如果表中的某一行没有使用，就会被删除，这样可以大大减少ARP缓存表的长度，加快查询速度。</p>
<p>当发送主机和目的主机不在同一个局域网中时，即便知道目的主机的MAC地址，两者也不能直接通信，必须经过路由转发才可以。所以此时，发送主机通过ARP协议获得的将不是目的主机的真实MAC地址，而是一台可以通往局域网外的路由器的MAC地址。于是此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。这种情况称为ARP代理（ARP Proxy）。</p>
<h1 id="ICMP（互联网控制消息协议）"><a href="#ICMP（互联网控制消息协议）" class="headerlink" title="ICMP（互联网控制消息协议）"></a>ICMP（互联网控制消息协议）</h1><p>它 用于TCP/IP网络中发送控制消息，提供可能发生在通信环境中的各种问题反馈，通过这些信息，令管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。它与传输协议最大的不同：它一般不用于在两点间传输数据，而常常 用于返回的错误信息或是分析路由。</p>
<p>ICMP控制的内容包括但不仅限于：echo响应（ping）、目标网络不可达、目标端口不可达、禁止访问的网络、拥塞控制、重定向、TTL超时…</p>
<h1 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h1><p>路由选择协议分为：静态的和动态的。Internet中使用的是动态路由选择协议，在Internet的概念中，将整个互联网划分为许多个小的自治系统（AS）。AS的最主要的特征：一个AS对其他AS表现出的是一个单一 和一致的路由选择策略。</p>
<p>由于AS的存在，路由选择协议又分为两种：</p>
<p>内部网关协议（IGP）：即在一个AS内部使用的路由选择协议，而这与互联网中其他AS选用什么路由协议无关。比如：OSPF<br>外部网关协议（EGP）：若源主机和目的主机不再同一个AS中，就需要使用一种协议将路由选择信息传递到另一个AS中，这就是EGP。比如：BGP。</p>
<h1 id="OSPF（开放式最短路径优先）"><a href="#OSPF（开放式最短路径优先）" class="headerlink" title="OSPF（开放式最短路径优先）"></a>OSPF（开放式最短路径优先）</h1><p>OSPF属于内部网关协议（IGP）的一种，使用Dijkstra提出的最短路径算法。</p>
<p>OSPF提出了“区域（Area）”的概念，一个网络可以由单一区域或者多个区域组成。其中，一个特别的区域被称为骨干区域（Backbone Area），该区域是整个OSPF网络的核心区域，并且所有其他的区域都与之直接连接。所有的内部路由都通过骨干区域传递到其他非骨干区域。所有的区域都必须直接连接到骨干区域，如果不能创建直接连接，那么可以通过虚拟链路（Virtual-link）和骨干区域创建虚拟连接。</p>
<p>划分区域的优点：</p>
<p>将洪泛法的范围限制在一个区域中。</p>
<p>减少每个区域内部路由信息交换的通信量。</p>
<p>OSPF使用的是分布式链路状态协议，使用 洪泛法向该路由器所有的相邻路由器发送信息。最终整个区域的所有路由器都得到一个这个信息的副本。这个副本就是 链路状态数据库（LSDB）用来保存当前网络拓扑结构，路由器上属于同一区域的链路状态数据库是相同的（属于多个区域的路由器会为每个区域维护一份链路状态数据库）。</p>
<p>OSPF使用 <strong>“代价（Cost）”</strong>作为路由度量。</p>
<p>只有当链路发生变化时才会更新信息。</p>
<p>如果同一个目的网络有多条路径，OSPF协议可以进行 负载均衡。</p>
<h1 id="BGP（边界网关协议）"><a href="#BGP（边界网关协议）" class="headerlink" title="BGP（边界网关协议）"></a>BGP（边界网关协议）</h1><p>由于BGP是工作在AS之间的协议，并且各个AS的情况复杂，所以 BGP只是力求找到一个可以到达目的网络且比较好的路由，而并不是寻找一条最佳路由。每一个AS都应该有一个<strong>“BGP发言人“，一般来说，两个BGP发言人是通过一个共享网络连接在一起的，BGP发言人往往是BGP边界路由</strong>，但也可以不是。</p>
<p>一个BGP发言人与其他AS的BGP发言人要交换路由信息，首先要建立TCP连接，然后在此连接上交换BGP报文以建立BGP会话。当BGP发言人交换了路由信息后，就构造自治系统连通图，最后通过该图来进行路由选择。</p>
<h1 id="DHCP（动态主机设置协议）"><a href="#DHCP（动态主机设置协议）" class="headerlink" title="DHCP（动态主机设置协议）"></a>DHCP（动态主机设置协议）</h1><p>DHCP是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：</p>
<p>用于内部网络或网络服务供应商自动分配IP地址给用户<br>用于内部网络管理员作为对所有电脑作中央管理的手段<br>动态主机设置协议（DHCP）是一种使网络管理员能够集中管理和自动分配IP网络地址的通信协议。在IP网络中，每个连接Internet的设备都需要分配唯一的IP地址。DHCP使网络管理员能从中心结点监控和分配IP地址。当某台计算机移到网络中的其它位置时，能自动收到新的IP地址。</p>
<p>DHCP使用了 租约 的概念，或称为计算机IP地址的有效期。租用时间是不定的，主要取决于用户在某地连接Internet需要多久，这对于教育行业和其它用户频繁改变的环境是很实用的。通过较短的租期，DHCP能够在一个计算机比可用IP地址多的环境中动态地重新配置网络。DHCP支持为计算机分配静态地址，如需要永久性IP地址的Web服务器。</p>
<h1 id="NAT（地址转换协议）"><a href="#NAT（地址转换协议）" class="headerlink" title="NAT（地址转换协议）"></a>NAT（地址转换协议）</h1><p>NAT是一种 在IP封包通过路由器或防火墙时重写来源IP地址或目的IP地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有IP地址访问因特网的私有网络中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/18/一些网络协议/" data-id="cjjqsy7sv0001qkv8wotf3c70" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/03/17/RxJava简介/" itemprop="url">
                  RxJava简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-03-17T17:02:40+08:00" content="2016-03-17">
              2016-03-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/17/RxJava简介/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/17/RxJava简介/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">给 Android 开发者的 RxJava 详解</a></p>
<p>导入依赖<br><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava github</a><br><a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="external">RxAndroid github</a></p>
<p>compile ‘io.reactivex:rxjava:1.1.0’<br>compile ‘io.reactivex:rxandroid:1.1.0’ </p>
<h2 id="使用RxJava的好处"><a href="#使用RxJava的好处" class="headerlink" title="使用RxJava的好处"></a>使用RxJava的好处</h2><p>RxJava代替AsyncTask和Handler使得代码逻辑上保持简洁。</p>
<h2 id="RxJava-的观察者模式"><a href="#RxJava-的观察者模式" class="headerlink" title="RxJava 的观察者模式"></a>RxJava 的观察者模式</h2><p>RxJava 有四个基本概念：Observable (可观察者，即被观察者)、 Observer (观察者)、subscribe (订阅)、事件。Observable 和 Observer 通过 subscribe()方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。</p>
<p>与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 onNext()（相当于onClick() / onEvent()）之外，还定义了两个特殊的事件：onCompleted() 和 onError()。</p>
<p>onCompleted(): 事件队列完结。RxJava不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 onNext() 发出时，需要触发 onCompleted() 方法作为标志。<br>onError(): 事件队列异常。在事件处理过程中出异常时，onError()会被触发，同时队列自动终止，不允许再有事件发出。<br>在一个正确运行的事件序列中, onCompleted() 和 onError()有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted() 和 onError() 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。</p>
<h2 id="线程控制Scheduler"><a href="#线程控制Scheduler" class="headerlink" title="线程控制Scheduler"></a>线程控制Scheduler</h2><p>在不指定线程的情况下，RxJava遵循的是线程不变的原则，即：在哪个线程调用subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。</p>
<p>Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的Scheduler。<br>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。<br>Schedulers.io():I/O操作（读写文件、读写数据库、网络信息交互等）所使用的Scheduler。行为模式和 newThread() 差不多，区别在于 io()的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io()中，可以避免创建不必要的线程。<br>Schedulers.computation():计算所使用的Scheduler。这个计算指的是CPU密集型计算，即不会被 I/O等操作限制性能的操作，例如图形的计算。这个Scheduler使用的固定的线程池，大小为CPU核数。不要把 I/O 操作放在 computation()中，否则I/O操作的等待时间会浪费CPU。<br>另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。</p>
<p>有了这几个 Scheduler ，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。</p>
<p>subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。<br>observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。</p>
<p>eg:</p>
<pre><code>Observable.just(1, 2, 3, 4)
    .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程
    .observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程
    .subscribe(new Action1&lt;Integer&gt;() {
        @Override
        public void call(Integer number) {
            Log.d(tag, &quot;number:&quot; + number);
        }
    });
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/03/16/dagger2依赖注入/" itemprop="url">
                  dagger2依赖注入
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-03-16T11:44:03+08:00" content="2016-03-16">
              2016-03-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/16/dagger2依赖注入/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/16/dagger2依赖注入/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="dagger2的作用"><a href="#dagger2的作用" class="headerlink" title="dagger2的作用"></a>dagger2的作用</h2><p><a href="https://yongjhih.gitbooks.io/feed/content/dagger2.html" target="_blank" rel="external">Dagger2介绍</a><br><a href="http://zane96.github.io/2016/01/22/DI%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8ADagger%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="external">DI理解以及Dagger生成代码分析</a></p>
<p>依赖的注入和配置独立于组件之外，注入的对象在一个独立、不耦合的地方初始化，这样在改变注入对象时，我们只需要修改对象的实现方法，而不用大改代码库。</p>
<p>依赖可以注入到一个组件中：我们可以注入这些依赖的模拟实现，这样使得测试更加简单。</p>
<p>app中的组件不需要知道有关实例创建和生命周期的任何事情，这些由我们的依赖注入框架管理的。</p>
<h2 id="主要的注解"><a href="#主要的注解" class="headerlink" title="主要的注解"></a>主要的注解</h2><p>@Inject: 通常在需要依赖的地方使用这个注解。换句话说，你用它告诉Dagger这个类或者字段需要依赖注入。这样，Dagger就会构造一个这个类的实例并满足他们的依赖。</p>
<p>@Module: Modules类里面的方法专门提供依赖，所以我们定义一个类，用@Module注解，这样Dagger在构造类的实例的时候，就知道从哪里去找到需要的依赖。modules的一个重要特征是它们设计为分区并组合在一起（比如说，在我们的app中可以有多个组成在一起的modules）。</p>
<p>@Provides: 在modules中，我们定义的方法是用这个注解，以此来告诉Dagger我们想要构造对象并提供这些依赖。</p>
<p>@Component: Components从根本上来说就是一个注入器，也可以说是@Inject和@Module的桥梁，它的主要作用就是连接这两个部分。 Components可以提供所有定义了的类型的实例，比如：我们必须用@Component注解一个接口然后列出所有的@Modules组成该组件，如 果缺失了任何一块都会在编译的时候报错。所有的组件都可以通过它的modules知道依赖的范围。</p>
<p>@Scope: Scopes可是非常的有用，Dagger2可以通过自定义注解限定注解作用域。后面会演示一个例子，这是一个非常强大的特点，因为就如前面说的一样，没必要让每个对象都去了解如何管理他们的实例。</p>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>使用dagger2首先要构建module类<br>代码如下:</p>
<pre><code>@Module
public class Boss {  
    @Inject
    public Boss(){
    }
}
</code></pre><p>接着构建Component接口作为module和要注入类之间的桥梁<br>代码如下：</p>
<pre><code>@Singleton
@Component(modules =  Boss.class)
public interface BossComponent {
    void inject(MainActivity mainActivity);
}
</code></pre><p>被注入类MainActivity如下：</p>
<pre><code>public class MainActivity extends AppCompatActivity {
    @Inject
    Boss mBoss;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        BossComponent bossComponent = DaggerBossComponent.builder()
                            .boss(new Boss())
                            .build();
        bossComponent.inject(this);
    }
}
</code></pre><p>在这里可以看到由Dagger生成了一个辅助类DaggerBossComponent。<br>DaggerBossComponent.builder()获取了一个静态内部类Builder的对象。<br>代码如下：</p>
<pre><code>public static Builder builder() {  
    return new Builder();
}
</code></pre><p>Builder类有一个Boss成员变量还有一个boss方法。</p>
<pre><code>public Builder boss(Boss boss) {  
    if (boss == null) {
        throw new NullPointerException(&quot;boss&quot;);
    }
    this.boss = boss;
    return this;
}
</code></pre><p>之后调用build方法</p>
<pre><code>public BossComponent build() {  
    if (boss == null) {
        this.boss = new Boss();
    }
    return new DaggerBossComponent(this);
}
</code></pre><p>这里我不太明白为什么又判断一次boss为null，最后build()方法创建了DaggerBossComponent对象，DaggerBossComponent部分代码如下：</p>
<pre><code>private MembersInjector&lt;MainActivity&gt; mainActivityMembersInjector;

private DaggerBossComponent(Builder builder) {  
    assert builder != null;
    initialize(builder);
}

private void initialize(final Builder builder) {  
    this.mainActivityMembersInjector = MainActivity_MembersInjector.create((MembersInjector) MembersInjectors.noOp(), Boss_Factory.create());
}

@Override
public void inject(MainActivity mainActivity) {  
    mainActivityMembersInjector.injectMembers(mainActivity);
}
</code></pre><p>MainActivity_MembersInjector类实现了MembersInjector这个接口，MainActivity_MembersInjector.create中完成了各种初始化，并在injectMembers中完成对mBoss的赋值。<br>代码如下：</p>
<pre><code>@Generated(&quot;dagger.internal.codegen.ComponentProcessor&quot;)
public final class MainActivity_MembersInjector implements MembersInjector&lt;MainActivity&gt; {
    private final MembersInjector&lt;AppCompatActivity&gt; supertypeInjector;
    private final Provider&lt;Boss&gt; mBossProvider;

    public MainActivity_MembersInjector(MembersInjector&lt;AppCompatActivity&gt; supertypeInjector, Provider&lt;Boss&gt; mBossProvider) {  
        assert supertypeInjector != null;
        this.supertypeInjector = supertypeInjector;
        assert mBossProvider != null;
        this.mBossProvider = mBossProvider;
    }

    @Override
    public void injectMembers(MainActivity instance) {  
        if (instance == null) {
            throw new NullPointerException(&quot;Cannot inject members into a null reference&quot;);
        }
        supertypeInjector.injectMembers(instance);
        instance.mBoss = mBossProvider.get();
    }

    public static MembersInjector&lt;MainActivity&gt; create(MembersInjector&lt;AppCompatActivity&gt; supertypeInjector, Provider&lt;Boss&gt; mBossProvider) {  
        return new MainActivity_MembersInjector(supertypeInjector, mBossProvider);
    }
}
</code></pre><p>因此bossComponent.inject(this)调用方法如下：</p>
<pre><code>bossComponent.inject(this)
    -&gt;DaggerBossComponent.inject(MainActivity)
    -&gt;MainActivity_MembersInjector.injectMembers(MainActivity)
</code></pre><p>除了上述这种用@Inject注释构造函数的情况外，我们还可以使用@Provides来告诉Dagger我们想要构造对象。</p>
<pre><code>@Provides
public Boss getBoss(){
    return new Boss();
}
</code></pre><p><a href="https://github.com/wuhanzhouguanjie/dagger2example" target="_blank" rel="external">Dagger2+MVP实例代码</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/03/15/Android-MVP模式/" itemprop="url">
                  Android MVP模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-03-15T14:59:36+08:00" content="2016-03-15">
              2016-03-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/15/Android-MVP模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/15/Android-MVP模式/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>传统MVC模式中：<br>View对应于布局文件<br>Model业务逻辑和实体模型<br>Controllor对应于Activity</p>
<p>但是实际开发过程中，我们又通常将事件处理的代码都在Activity中，造成了Activity既像View又像Controller。<br><img src="https://raw.githubusercontent.com/wuhanzhouguanjie/wuhanzhouguanjie.github.io/master/uploads/mvc.png"></p>
<p>而MVP模式中：<br>View 对应于Activity，负责View的绘制以及与用户交互<br>Model 依然是业务逻辑和实体模型<br>Presenter 负责完成View于Model间的交互<br><img src="https://raw.githubusercontent.com/wuhanzhouguanjie/wuhanzhouguanjie.github.io/master/uploads/mvp.png"></p>
<h2 id="MVP和MVC的区别"><a href="#MVP和MVC的区别" class="headerlink" title="MVP和MVC的区别"></a>MVP和MVC的区别</h2><p><img src="https://raw.githubusercontent.com/wuhanzhouguanjie/wuhanzhouguanjie.github.io/master/uploads/diff_mvp_mvc.png"></p>
<p>MVC中是允许Model和View进行交互的，而MVP中很明显，Model与View之间的交互由Presenter完成。还有一点就是Presenter与View之间的交互是通过接口的</p>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p><img src="https://raw.githubusercontent.com/wuhanzhouguanjie/wuhanzhouguanjie.github.io/master/uploads/mvp_code.png"></p>
<p>1.M层对象：</p>
<pre><code>public class UserBean {
     private String mFirstName;
     private String mLastName;

     public UserBean(String firstName, String lastName) {
            this. mFirstName = firstName;
            this. mLastName = lastName;
     }

     public String getFirstName() {
            return mFirstName;
     }

     public String getLastName() {
            return mLastName;
     }
}
</code></pre><p>2.M层创建处理业务逻辑接口</p>
<pre><code>public interface IUserModel {
     void setID(int id);
     void setFirstName(String firstName);
     void setLastName(String lastName);
     int getID();
     UserBean load(int id);// 通过id读取user信息,返回一个UserBean
}
</code></pre><p>3.M层实现IUserView</p>
<pre><code>public class UserModel implements IUserModel{
    ...
}
</code></pre><p>4.V层更新ui中的view状态接口</p>
<pre><code>public interface IUserView {
     int getID();
     String getFristName();
     String getLastName();
     void setFirstName(String firstName);
     void setLastName(String lastName);
}
</code></pre><p>4.P层presenter完成交互</p>
<pre><code>public class UserPresenter {
     private IUserView mUserView;
     private IUserModel mUserModel;

     public UserPresenter(IUserView view) {
            mUserView = view;
            mUserModel = new UserModel();
     }

     public void saveUser( int id, String firstName, String lastName) {
            mUserModel.setID(id);
            mUserModel.setFirstName(firstName);
            mUserModel.setLastName(lastName);
     }

     public void loadUser( int id) {
           UserBean user = mUserModel.load(id);
            mUserView.setFirstName(user.getFirstName()); // 通过调用IUserView的方法来更新显示
            mUserView.setLastName(user.getLastName());
     }
}
</code></pre><p>5.V层activity中实现接口</p>
<pre><code>public class MainActivity extends Activity implements OnClickListener,IUserView {

     UserPresenter presenter;
     EditText id,first,last;
     @Override
     protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
           setContentView(R.layout. activity_main);

           findViewById(R.id. save).setOnClickListener( this);
           findViewById(R.id. load).setOnClickListener( this);
            id = (EditText) findViewById(R.id. id);
            first = (EditText) findViewById(R.id. first);
            last = (EditText) findViewById(R.id. last);

            presenter = new UserPresenter( this);
     }

     @Override
     public void onClick(View v) {
            switch (v.getId()) {
            case R.id. save:
                 presenter.saveUser(getID(), getFristName(), getLastName());
                 break;
            case R.id. load:
                 presenter.loadUser(getID());
                 break;
            default:
                 break;
           }
     }

     @Override
     public int getID() {
            return new Integer( id.getText().toString());
     }

     @Override
     public String getFristName() {
            return first.getText().toString();
     }

     @Override
     public String getLastName() {
            return last.getText().toString();
     }

     @Override
     public void setFirstName(String firstName) {
            first.setText(firstName);
     }

     @Override
     public void setLastName(String lastName) {
            last.setText(lastName);
     }

}
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/03/11/Android混淆/" itemprop="url">
                  Android混淆
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-03-11T10:34:26+08:00" content="2016-03-11">
              2016-03-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/11/Android混淆/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/11/Android混淆/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="proguard简介"><a href="#proguard简介" class="headerlink" title="proguard简介"></a>proguard简介</h2><p>由于java代码容易被反编译，因此android中常用proguard来进行代码混淆。它是对编译好的class文件进行混淆处理，在分析class的同时，他还有其他两个功能，删除无效代码（Shrinking 收缩），和代码进行优化 （Optimization Options）。</p>
<p>缺省情况下，proguard 会混淆所有代码，但是下面几种情况是不能改变java 元素的名称，否则就会这样就会导致程序出错。<br>一， 我们用到反射的地方。<br>二， 我们代码依赖于系统的接口，比如被系统代码调用的回调方法，这种情况最复杂。<br>三， 是我们的java 元素名称是在配置文件中配置好的。<br>所以使用proguard时，我们需要有个配置文件告诉proguard 那些java元素是不能混淆的。</p>
<h2 id="proguard配置"><a href="#proguard配置" class="headerlink" title="proguard配置"></a>proguard配置</h2><p>最常用的配置选项</p>
<pre><code>-dontwarn 缺省proguard 会检查每一个引用是否正确，但是第三方库里面往往有些不会用到的类，没有正确引用。如果不配置的话，系统就会报错。
-keep 指定的类和类成员被保留作为 入口 。
-keepclassmembers 指定的类成员被保留。
-keepclasseswithmembers 指定的类和类成员被保留，假如指定的类成员存在的话。
</code></pre><p>其它选项</p>
<pre><code>-include {filename}    从给定的文件中读取配置参数 
-basedirectory {directoryname}    指定基础目录为以后相对的档案名称 
-injars {class_path}    指定要处理的应用程序jar,war,ear和目录 
-outjars {class_path}    指定处理完后要输出的jar,war,ear和目录的名称 
-libraryjars {classpath}    指定要处理的应用程序jar,war,ear和目录所需要的程序库文件 
-dontskipnonpubliclibraryclasses    指定不去忽略非公共的库类。 
-dontskipnonpubliclibraryclassmembers    指定不去忽略包可见的库类的成员。

保留选项 
-keep {Modifier} {class_specification}    保护指定的类文件和类的成员 
-keepclassmembers {modifier} {class_specification}    保护指定类的成员，如果此类受到保护他们会保护的更好
-keepclasseswithmembers {class_specification}    保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。 
-keepnames {class_specification}    保护指定的类和类的成员的名称（如果他们不会压缩步骤中删除） 
-keepclassmembernames {class_specification}    保护指定的类的成员的名称（如果他们不会压缩步骤中删除） 
-keepclasseswithmembernames {class_specification}    保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后） 
-printseeds {filename}    列出类和类的成员-keep选项的清单，标准输出到给定的文件 

压缩 
-dontshrink    不压缩输入的类文件 
-printusage {filename} 
-dontwarn   如果有警告也不终止
-whyareyoukeeping {class_specification}     

优化 
-dontoptimize    不优化输入的类文件 
-assumenosideeffects {class_specification}    优化时假设指定的方法，没有任何副作用 
-allowaccessmodification    优化时允许访问并修改有修饰符的类和类的成员 

混淆 
-dontobfuscate    不混淆输入的类文件 
-printmapping {filename} 
-applymapping {filename}    重用映射增加混淆 
-obfuscationdictionary {filename}    使用给定文件中的关键字作为要混淆方法的名称 
-overloadaggressively    混淆时应用侵入式重载 
-useuniqueclassmembernames    确定统一的混淆类的成员名称来增加混淆 
-flattenpackagehierarchy {package_name}    重新包装所有重命名的包并放在给定的单一包中 
-repackageclass {package_name}    重新包装所有重命名的类文件中放在给定的单一包中 
-dontusemixedcaseclassnames    混淆时不会产生形形色色的类名 
-keepattributes {attribute_name,...}    保护给定的可选属性，例如LineNumberTable, LocalVariableTable, SourceFile, Deprecated, Synthetic, Signature, and 

InnerClasses. 
-renamesourcefileattribute {string}    设置源文件中给定的字符串常量
</code></pre><h2 id="proguard-问题和风险"><a href="#proguard-问题和风险" class="headerlink" title="proguard 问题和风险"></a>proguard 问题和风险</h2><p>代码混淆后虽然有混淆优化的好处，但是它往往也会带来如下的几点问题<br>1，混淆错误，用到第三方库的时候，必须告诉 proguard 不要检查，否则proguard 会报错。<br>2，运行错误，当code不能混淆的时候，我们必须要正确配置，否则程序会运行出错，这种情况问题最多。<br>3，调试苦难，出错了，错误堆栈是混淆后的代码，自己也看不懂。</p>
<p>常见的不能混淆的androidCode<br>Android 程序 ，下面这样代码混淆的时候要注意保留。<br>Android系统组件，系统组件有固定的方法被系统调用。<br>被Android Resource 文件引用到的。名字已经固定，也不能混淆，比如自定义的View 。<br>Android Parcelable ，需要使用android 序列化的。<br>其他Anroid 官方建议 不混淆的，如<br>android.app.backup.BackupAgentHelper<br>android.preference.Preference<br>com.android.vending.licensing.ILicensingService<br>Java序列化方法，系统序列化需要固定的方法。<br>枚举 ，系统需要处理枚举的固定方法。<br>本地方法，不能修改本地方法名<br>annotations 注释<br>数据库驱动<br>有些resource 文件<br>用到反射的地方</p>
<p>如何实施<br>现在的系统已经配置为混淆时候会保留<br>Android系统组件<br>自定义View<br>Android Parcelable<br>Android R 文件<br>Android Parcelable<br>枚举<br>各个开发人员必须检查自己的code 是否用到反射，和其他不能混淆的地方。告诉我来修改配置文件（已经保留的就不需要了）。</p>
<h2 id="Android-Studio中使用混淆"><a href="#Android-Studio中使用混淆" class="headerlink" title="Android Studio中使用混淆"></a>Android Studio中使用混淆</h2><p>在gradle中进行设置</p>
<pre><code>buildTypes {
       release {
           minifyEnabled true
           proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
       }
   }
</code></pre><p>proguardFiles这部分有两段，前一部分代表系统默认的android程序的混淆文件，该文件已经包含了基本的混淆声明，免去了我们很多事，这个文件的目录在/tools/proguard/proguard-android.txt ,后一部分是我们项目里的自定义的混淆文件，目录就在app/proguard-rules.txt , 如果你用Studio 1.0创建的新项目默认生成的文件名是 proguard-rules.pro , 这个名字没关系，在这个文件里你可以声明一些第三方依赖的一些混淆规则。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre><code>-optimizationpasses 7  #指定代码的压缩级别 0 - 7
-dontusemixedcaseclassnames  #是否使用大小写混合
-dontskipnonpubliclibraryclasses  #如果应用程序引入的有jar包，并且想混淆jar包里面的class
-dontpreverify  #混淆时是否做预校验（可去掉加快混淆速度）
-verbose #混淆时是否记录日志（混淆后生产映射文件 map 类名 -&gt; 转化后类名的映射
-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*  #淆采用的算法

-keep public class * extends android.app.Activity  #所有activity的子类不要去混淆
-keep public class * extends android.app.Application
-keep public class * extends android.app.Service
-keep public class * extends android.content.BroadcastReceiver
-keep public class * extends android.content.ContentProvider
-keep public class * extends android.app.backup.BackupAgentHelper
-keep public class * extends android.preference.Preference
-keep public class com.android.vending.licensing.ILicensingService #指定具体类不要去混淆

-keepclasseswithmembernames class * {
    native &lt;methods&gt;;  #保持 native 的方法不去混淆
}

-keepclasseswithmembers class * {
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);  #保持自定义控件类不被混淆，指定格式的构造方法不去混淆
}

-keepclasseswithmembers class * {
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);
}

-keepclassmembers class * extends android.app.Activity { 
    public void *(android.view.View); #保持指定规则的方法不被混淆（Android layout 布局文件中为控件配置的onClick方法不能混淆）
}

-keep public class * extends android.view.View {  #保持自定义控件指定规则的方法不被混淆
    public &lt;init&gt;(android.content.Context);
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);
    public void set*(...);
}

-keepclassmembers enum * {  #保持枚举 enum 不被混淆
    public static **[] values();
    public static ** valueOf(java.lang.String);
}

-keep class * implements android.os.Parcelable {  #保持 Parcelable 不被混淆（aidl文件不能去混淆）
    public static final android.os.Parcelable$Creator *;
}

-keepnames class * implements java.io.Serializable #需要序列化和反序列化的类不能被混淆（注：Java反射用到的类也不能被混淆）

-keepclassmembers class * implements java.io.Serializable { #保护实现接口Serializable的类中，指定规则的类成员不被混淆
    static final long serialVersionUID;
    private static final java.io.ObjectStreamField[] serialPersistentFields;
    !static !transient &lt;fields&gt;;
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    java.lang.Object writeReplace();
    java.lang.Object readResolve();
}

-keepattributes Signature  #过滤泛型（不写可能会出现类型转换错误，一般情况把这个加上就是了）

-keepattributes *Annotation*  #假如项目中有用到注解，应加入这行配置

-keep class **.R$* { *; }  #保持R文件不被混淆，否则，你的反射是获取不到资源id的

-keep class **.Webview2JsInterface { *; }  #保护WebView对HTML页面的API不被混淆
-keepclassmembers class * extends android.webkit.WebViewClient {  #如果你的项目中用到了webview的复杂操作 ，最好加入
     public void *(android.webkit.WebView,java.lang.String,android.graphics.Bitmap);
     public boolean *(android.webkit.WebView,java.lang.String);
}
-keepclassmembers class * extends android.webkit.WebChromeClient {  #如果你的项目中用到了webview的复杂操作 ，最好加入
     public void *(android.webkit.WebView,java.lang.String);
}
#对WebView的简单说明下：经过实战检验,做腾讯QQ登录，如果引用他们提供的jar，若不加防止WebChromeClient混淆的代码，oauth认证无法回调，反编译基代码后可看到他们有用到WebChromeClient，加入此代码即可。

-keepclassmembernames class com.cgv.cn.movie.common.bean.** { *; }  #转换JSON的JavaBean，类成员名称保护，使其不被混淆

##################################################################
# 下面都是项目中引入的第三方 jar 包。第三方 jar 包中的代码不是我们的目标和关心的对象，故而对此我们全部忽略不进行混淆。
##################################################################
-libraryjars  libs/android-support-v4.jar
-dontwarn android.support.v4.**
-keep class android.support.v4.** { *; }  
-keep interface android.support.v4.** { *; }
-keep public class * extends android.support.v4.** 
-keep public class * extends android.app.Fragment

-libraryjars libs/gson-2.3.1-sources.jar
-libraryjars libs/gson-2.3.1.jar
-dontwarn com.google.gson.**    
-keep class sun.misc.Unsafe { *; }
-keep class com.google.gson.** { *; }

-libraryjars libs/alipaySDK-20150602.jar
-dontwarn com.alipay.**    
-dontwarn com.ta.utdid2.**    
-dontwarn com.ut.device.**    
-keep class com.alipay.** { *; }
-keep class com.ta.utdid2.** { *; }
-keep class com.ut.device.** { *; }

-libraryjars libs/android-async-http-1.4.6.jar
-dontwarn com.loopj.android.http.**
-keep class com.loopj.android.http.** { *; }

-libraryjars libs/baidumapapi_v2_4_1.jar
-dontwarn com.baidu.**
-keep class com.baidu.** {*; }
-keep class assets.** {*; }
-keep class vi.com.gdi.bgl.** {*; }

-libraryjars libs/libammsdk.jar
-dontwarn com.tencent.**
-keep class com.tencent.** { *; }

-libraryjars libs/locSDK_4.1.jar
-dontwarn com.baidu.location.**
-keep class com.baidu.location.** { *; }

-libraryjars libs/mframework.jar
-dontwarn m.framework.**
-keep class m.framework.** { *; }

-libraryjars libs/mta-sdk-1.6.2.jar
-dontwarn com.tencent.stat.**
-keep class com.tencent.stat.** { *; }

-libraryjars libs/nineoldandroids-library-2.4.0.jar
-dontwarn com.nineoldandroids.**
-keep class com.nineoldandroids.** { *; }

-libraryjars libs/open_sdk_r4889.jar
-dontwarn com.tencent.**
-keep class com.tencent.** { *; } 

-libraryjars libs/ShareSDK-Core-2.5.9.jar
-dontwarn cn.sharesdk.framework.**
-keep class cn.sharesdk.framework.** { *; } 

-libraryjars libs/ShareSDK-ShortMessage-2.5.9.jar
-dontwarn cn.sharesdk.system.text.**
-keep class cn.sharesdk.system.text.** { *; } 

-libraryjars libs/ShareSDK-SinaWeibo-2.5.9.jar
-dontwarn cn.sharesdk.sina.weibo.**
-keep class cn.sharesdk.sina.weibo.** { *; } 

-libraryjars libs/ShareSDK-Wechat-2.5.9.jar
-dontwarn cn.sharesdk.wechat.friends.**
-keep class cn.sharesdk.wechat.friends.** { *; } 

-libraryjars libs/ShareSDK-Wechat-Core-2.5.9.jar
-dontwarn cn.sharesdk.wechat.utils.**
-keep class cn.sharesdk.wechat.utils.** { *; } 

-libraryjars libs/ShareSDK-Wechat-Favorite-2.5.9.jar
-dontwarn cn.sharesdk.wechat.favorite.**
-keep class cn.sharesdk.wechat.favorite.** { *; } 

-libraryjars libs/ShareSDK-Wechat-Moments-2.5.9.jar
-dontwarn cn.sharesdk.wechat.moments.**
-keep class cn.sharesdk.wechat.moments.** { *; } 

-libraryjars libs/universal-image-loader-1.9.2-SNAPSHOT-with-sources.jar
-dontwarn com.nostra13.universalimageloader.**
-keep class com.nostra13.universalimageloader.** { *; } 

-libraryjars libs/weibosdkcore.jar
-dontwarn com.sina.weibo.sdk.**
-keep class com.sina.weibo.sdk.** { *; }
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/03/07/Android-TextView设置字间距和行间距/" itemprop="url">
                  Android TextView设置字间距和行间距
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-03-07T15:23:56+08:00" content="2016-03-07">
              2016-03-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/07/Android-TextView设置字间距和行间距/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/07/Android-TextView设置字间距和行间距/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p><a href="http://blog.csdn.net/nsw911439370/article/details/41542861?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">原文</a></p>
<h3 id="设置TextView的行间距"><a href="#设置TextView的行间距" class="headerlink" title="设置TextView的行间距"></a>设置TextView的行间距</h3><pre><code>android:lineSpacingMultiplier=&quot;1.8&quot;  
</code></pre><h3 id="设置字间距需要自定义控件"><a href="#设置字间距需要自定义控件" class="headerlink" title="设置字间距需要自定义控件"></a>设置字间距需要自定义控件</h3><pre><code>import android.graphics.*;  
import android.text.TextUtils;  
import android.util.AttributeSet;  
import android.widget.TextView;  

import java.util.regex.Matcher;  
import java.util.regex.Pattern;  

/** 
 - Created by mrni-mac on 14-11-25. 
 */  
public class MyTextView extends TextView {  
    private String content;  
    private int width;  
    private Paint paint;  
    private int xPadding;  
    private int yPadding;  
    private int textHeight;  
    private int xPaddingMin;  
    int count;  
    //记录每个字的二维数组  
    int[][] position;  

    public MyTextView(Context context) {  
        super(context);  
        init();  
    }  

    public MyTextView(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        init();  
    }  

    public MyTextView(Context context, AttributeSet attrs, int defStyle) {  
        super(context, attrs, defStyle);  
        init();  
    }  

    public void setText(String str) {  
        width = this.getWidth();  
        getPositions(str);  
        //重新画控件  
        this.invalidate();  
    }  
    public void init() {  

        paint = new Paint();  
        paint.setColor(Color.parseColor(&quot;#888888&quot;));  
        paint.setTypeface(Typeface.DEFAULT);  
        paint.setTextSize(dip2px(this.getContext(), 14f));  
        Paint.FontMetrics fm = paint.getFontMetrics();// 得到系统默认字体属性  
        textHeight = (int) (Math.ceil(fm.descent - fm.top) + 2);// 获得字体高度  
        //字间距  
        xPadding = dip2px(this.getContext(), 4f);  
        //行间距  
        yPadding = dip2px(this.getContext(), 10f);  
        //比较小的字间距（字母和数字应紧凑）  
        xPaddingMin = dip2px(this.getContext(), 2f);  

    }  


    @Override  
    protected void onDraw(Canvas canvas) {  
        super.onDraw(canvas);  
        if (!TextUtils.isEmpty(content)) {  
            for (int i = 0; i &lt; count; i++) {  
                canvas.drawText(String.valueOf(content.charAt(i)), position[i][0],position[i][1], paint);  
            }  
        }  
    }  


    public void getPositions(String content) {  
        this.content = content;  
        char ch;  
        //输入点的 x的坐标  
        int x = 0;  
        //当前行数  
        int lineNum = 1;  
        count = content.length();  
        //初始化字体位置数组  
        position=new int[count][2];  
        for (int i = 0; i &lt; count; i++) {  
            ch =content.charAt(i);  
            String str = String.valueOf(ch);  

            //根据画笔获得每一个字符的显示的rect 就是包围框（获得字符宽度）  
            Rect rect = new Rect();  
            paint.getTextBounds(str, 0, 1, rect);  
            int strwidth = rect.width();  
            //对有些标点做些处理  
            if (str.equals(&quot;《&quot;) || str.equals(&quot;（&quot;)) {  
                strwidth += xPaddingMin * 2;  
            }  
            //当前行的宽度  
            float textWith = strwidth;  
            //没画字前预判看是否会出界  
            x += textWith;  
            //出界就换行  
            if (x &gt; width) {  
                lineNum++;// 真实的行数加一  
                x = 0;  
            } else {  
                //回到预判前的位置  
                x -= textWith;  
            }  
            //记录每一个字的位置  
            position[i][0]=x;  
            position[i][1]=textHeight * lineNum + yPadding * (lineNum - 1);  
            //判断是否是数字还是字母 （数字和字母应该紧凑点）  
            //每次输入完毕 进入下一个输入位置准备就绪  
            if (isNumOrLetters(str)) {  
                x += textWith + xPaddingMin;  
            } else {  
                x += textWith + xPadding;  
            }  
        }  
        //根据所画的内容设置控件的高度  
        this.setHeight((textHeight +yPadding) * lineNum);  
    }  



    //工具类：判断是否是字母或者数字  
    public boolean isNumOrLetters(String str)  
    {  
        String regEx=&quot;^[A-Za-z0-9_]+$&quot;;  
        Pattern p=Pattern.compile(regEx);  
        Matcher m=p.matcher(str);  
        return m.matches();  
    }  
     // 工具类：在代码中使用dp的方法（因为代码中直接用数字表示的是像素）  
    public static int dip2px(Context context, float dip) {  
        final float scale = context.getResources().getDisplayMetrics().density;  
        return (int) (dip * scale + 0.5f);  
    }  
}  
</code></pre><p>xml使用如下</p>
<pre><code>&lt;当前包名.MyTextView  
                 android:layout_width=&quot;match_parent&quot;  
                 android:layout_height=&quot;wrap_content&quot;  
                 android:id=&quot;@+id/video_dec&quot;  
                /&gt;  
</code></pre><p>效果如下</p>
<p><img src="https://raw.githubusercontent.com/wuhanzhouguanjie/wuhanzhouguanjie.github.io/master/uploads/1.jpg"></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/03/04/Android事件传递机制及滑动冲突解决方案/" itemprop="url">
                  Android事件传递机制及滑动冲突解决方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-03-04T10:43:17+08:00" content="2016-03-04">
              2016-03-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/04/Android事件传递机制及滑动冲突解决方案/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/04/Android事件传递机制及滑动冲突解决方案/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h3 id="事件传递机制"><a href="#事件传递机制" class="headerlink" title="事件传递机制"></a>事件传递机制</h3><p>待更新.<br>1</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/03/03/Java复习/" itemprop="url">
                  Java复习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-03-03T11:27:16+08:00" content="2016-03-03">
              2016-03-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/03/Java复习/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/03/Java复习/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="final与static"><a href="#final与static" class="headerlink" title="final与static"></a>final与static</h2><h3 id="final的使用"><a href="#final的使用" class="headerlink" title="final的使用"></a>final的使用</h3><p>1.fianl变量，即该成员被修饰为常量，意味着不可修改。<br>2.final类，以指示不能扩展该类（不能有子类）。<br>3.final方法，指该方法不可被继承成员重新定义。<br>4.final类的引用、数组的时候，事实上指向的对象的数据依然可以被修改。不能修改的是本身的引用值。<br>5.final参数，对象变量传递的是其引用，为防止调用过程中无意的更改而修饰。</p>
<h3 id="static的使用"><a href="#static的使用" class="headerlink" title="static的使用"></a>static的使用</h3><p><b> 被static修饰的成员变量和成员方法独立于该类的任何对象。它不依赖类特定的实例，被类的所有实例共享。</b><br>1.static变量，JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问。<br>2.static（内部）类可以被其他类实例化和引用。<br>3.static代码块，static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果static代码块有多个则顺序执行。</p>
<h2 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h2><p>反射机制的优点就是可以实现动态创建对象和编译。</p>
<h3 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h3><p>Constructor类可以帮助我们获得类的构造方法。<br>代码如下：<br>User类</p>
<pre><code>public class User {
    private String userName;
    public String passWord;
    public int age;
    public User(){}
    public User(String userName){}
    public User(String userName,String passWord){
        this.userName = userName;
        this.passWord = passWord;
    }
    private User(int age){}
    protected  User(boolean isStudent){}
    public String getUserName() {
        return userName;
    }
    public void setUserName(String userName) {
        this.userName = userName;
    }
}
</code></pre><p>使用:</p>
<pre><code>Class cls = Class.forName(&quot;com.zgj.myapplication.User&quot;);//创建class对象
Object obj = cls.newInstance();//创建对象的实例
</code></pre><p>获取所有public 构造方法:        </p>
<pre><code>Constructor c[] = cls.getConstructors();
for(int i = 0; i &lt; c.length; i++) {
    Log.e(TAG,&quot;public i=&quot; + i + &quot; &quot; + c[i]);
}
</code></pre><p>获取指定类型的public构造方法:</p>
<pre><code>Class[] params = new Class[]{String.class,String.class};
Constructor c1 = cls.getConstructor(params);
Log.e(TAG,&quot;public &quot; + c1);
</code></pre><p>获取所有构造方法包含非public的:</p>
<pre><code>Constructor c2[] = cls.getDeclaredConstructors();
for(int i = 0; i &lt; c2.length; i++) {
    Log.e(TAG,&quot;ALL i=&quot; + i + &quot; &quot; + c2[i]);
}
</code></pre><p>获取指定参数的构造方法包含非public的:</p>
<pre><code>Class[] params1 = new Class[]{int.class};
Constructor c3 = cls.getDeclaredConstructor(params1);
Log.e(TAG,&quot;ALL &quot; + c3);
</code></pre><p>log输出如下:<br><img src="https://raw.githubusercontent.com/wuhanzhouguanjie/wuhanzhouguanjie.github.io/master/uploads/反射Constructor.png"></p>
<h3 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h3><p>Method类可以帮助我们获得类的方法。</p>
<p>根据方法名和参数列表获取公共方法:</p>
<pre><code>Class[] params2 = new Class[]{};
Method method = cls.getMethod(&quot;getUserName&quot;,params2);
Log.e(TAG,&quot;getMethod &quot; + method);
</code></pre><p>获取所有公共方法:</p>
<pre><code>Method[] method1 = cls.getMethods();
for(int i = 0; i &lt; method1.length; i++) {
    Log.e(TAG,&quot;all public method:i=&quot; + i + &quot; &quot; + method1[i]);
}
</code></pre><p>与Constructor类类似，Method也有getDeclaredMethod(String name, Class[] params)和getDeclaredMethods()来获取所有公共以及非公共method的方法。</p>
<p>log输出如下：<br><img src="https://raw.githubusercontent.com/wuhanzhouguanjie/wuhanzhouguanjie.github.io/master/uploads/反射Method.png"><br>由于所有类都继承了Object，因此里面包含了一些从Object继承而来的方法。</p>
<p>Method有一个invoke方法可以用来调用方法。私有方法要先设置setAccessible为true，否者会报错。</p>
<pre><code>Class[] params2 = new Class[]{int.class,String.class};
Method method = cls.getDeclaredMethod(&quot;test&quot;, params2);
method.setAccessible(true);
String str = (String)method.invoke(obj, new Object[]{20,&quot;zgj&quot;});
</code></pre><h3 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h3><p>获得指定name的域Field对象，name为域变量名（必须为public修饰）,可以为该Class或它的接口域：</p>
<pre><code>Field field = cls.getField(&quot;passWord&quot;);
Log.e(TAG,&quot;field &quot; + field);
</code></pre><p>获得所有公有修饰的域对象数组：</p>
<pre><code>Field[] fields = cls.getFields();
for(int i = 0; i &lt; fields.length; i++) {
    Log.e(TAG,&quot;all public fields:i=&quot; + i + &quot; &quot; + fields[i]);
}
</code></pre><p>Field getDeclaredField(String name) –可获得所有的域对象<br>Field[] getDeclaredFields() –获得所有的域对象数组</p>
<p>log输出如下：<br><img src="https://raw.githubusercontent.com/wuhanzhouguanjie/wuhanzhouguanjie.github.io/master/uploads/反射Field.png"></p>
<p>Field提供各种方法获得域的值，基本数据类型为getInt(Object obj),getByte(Object obj)等，obj – 含有Field域的原有对象。<br>引用数据类型可用get(Object obj)获得引用类型的对象（为Object声明）。<br>Field也提供方法更改域的值，更改后的值直接反应回对象当中，如set(Object obj, Object values).</p>
<pre><code>User user = new User(&quot;zgj&quot;,&quot;123&quot;);
Field field = user.getClass().getDeclaredField(&quot;userName&quot;);
//私有变量必须先设置Accessible为true
field.setAccessible(true);
Log.e(TAG, &quot;userName=&quot; + field.get(user));
field.set(user, &quot;用户名改了&quot;);
Log.e(TAG, &quot;userName=&quot; + user.getUserName());
</code></pre><h2 id="Java常用数据结构"><a href="#Java常用数据结构" class="headerlink" title="Java常用数据结构"></a>Java常用数据结构</h2><p>类层次关系如下：<br>Collection﻿<br>├List<br>│├LinkedList<br>│├ArrayList<br>│└Vector<br>│　└Stack<br>└Set<br>Map<br>├Hashtable<br>├HashMap<br>└WeakHashMap</p>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p>Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）。一些 Collection允许相同的元素而另一些不行。一些能排序而另一些不行。Java SDK不提供直接继承自Collection的类，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。<br>　　所有实现Collection接口的类都必须提供两个标准的构造函数：无参数的构造函数用于创建一个空的Collection，有一个 Collection参数的构造函数用于创建一个新的Collection，这个新的Collection与传入的Collection有相同的元素。后一个构造函数允许用户复制一个Collection。<br>　　如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下：</p>
<pre><code>// 获得一个迭代子
Iterator it = collection.iterator(); 
while(it.hasNext()) {
    Object obj = it.next(); 
}
</code></pre><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>有序(元素存入集合的顺序和取出的顺序一致)，元素都有索引。元素可以重复。</p>
<p><li>ArrayList</li><br>底层的数据结构是数组，线程不同步，ArrayList替代了Vector，查询元素的速度非常快。</p>
<p><li>LinkedList</li><br>底层的数据结构是链表，线程不同步，增删元素的速度非常快。</p>
<p><li>Vector</li><br>底层的数据结构是数组，线程同步的，但是Vector无论查询还是增删元素都比较慢。</p>
<p><li>Stack</li><br>继承自Vector，实现一个后进先出的堆栈。</p>
<p>可变长度数组的原理：当元素超出数组长度，会产生一个新数组，将原数组的数据复制到新数组中，再将新的元素添加到新数组中。ArrayList是按照原数组的50%延长。构造一个初始容量为10的空列表。Vector是按照原数组的100%延长。</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set是一种不包含重复的元素的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个 value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。</p>
<p><li>Hashtable</li><br>Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。<br>Hashtable通过initial capacity和load factor两个参数调整性能。通常缺省的load factor 0.75较好地实现了时间和空间的均衡。增大load factor可以节省空间但相应的查找时间将增大，这会影响像get和put这样的操作。<br>Hashtable是同步的。</p>
<p><li>HashMap</li><br>HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代子操作时间开销和HashMap 的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load factor过低。</p>
<p><li>WeakHashMap</li><br>WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。</p>
<p><b>在Android中提供了一个SparseArray稀疏数组来代替HashMap&lt;Integer,Object&gt;，所谓稀疏数组就是数组中大部分的内容值都未被使用（或都为零），在数组中仅有少部分的空间使用。因此造成内存空间的浪费，为了节省内存空间，并且不影响数组中原有的内容值，我们可以采用一种压缩的方式来表示稀疏数组的内容。</b></p>
<h2 id="常见的设计模式"><a href="#常见的设计模式" class="headerlink" title="常见的设计模式"></a>常见的设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>有时候我们需要使用一个实用类A，这个类A专门提供一些公共功能供别人调用，而本身并不会处理业务逻辑。由于类A会被许多类乃至线程调用，假设我们的程序非常庞大，在运行的过程中，会访问这个类A100次，为了调用类A的方法，需要先创建A的对象，A a = new A（）。这种方法在对A的访问量较少的情况下没问题，但是像我们这种情况，就会创建100个类A的实例，这100个实例是要占用内存的，从这种角度来说，就造成了大量不必要的开销。而单例模式，在整个程序生命周期中，只有一个实例，这样就不会造成不必要的内存消耗。</p>
<p>代码如下：</p>
<pre><code>public class Singleton {  

    private volatile static Singleton sSingleton;   
    private Singleton() {  
    }
    public static Singleton getInstance() {  
        if (sSingleton == null) { // line A  
            synchronized (Singleton.class) { // line C  
            if (sSingleton == null)  
                sSingleton = new Singleton();  // line B  
            }  
        }  
        return sSingleton;  
    }  
}  
</code></pre><p>上述代码近乎完美，可以满足几乎所有场合，double-check(DCL)在很大程度上可以满足高并发的需要，尽管如此，它还是有一些小缺点的，问题的关键在于尽管得到了Singleton的正确引用，但是却有可能访问到其成员变量的不正确值</p>
<pre><code>public class Singleton {  
    private Singleton(){  
    }  

    private static class InstanceHolder{  
        private static final Singleton instance = new Singleton();  
    }  

    public static Singleton getInstance(){  
        return InstanceHolder.instance;  
    }  
}  
</code></pre><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。<br>A实例调用B实例的方法，称为A依赖于B。如果使用new关键字来创建一个B实例（硬编码耦合），然后调用B实例的方法。一旦系统需要重构：需要使用C类来代替B类时，程序不得不改写A类代码。而用工厂模式则不需要关心B对象的实现、创建过程。</p>
<p>代码如下</p>
<p>Output，接口</p>
<pre><code>public interface Output
{
    //接口里定义的属性只能是常量
    intMAX_CACHE_LINE = 50;
    //接口里定义的只能是public的抽象实例方法
    void out();
    void getData(String msg);
}
</code></pre><p>Printer，Output的一个实现<br>//让Printer类实现Output</p>
<pre><code>public class Printer implements Output
{
    private String[] printData = new String[MAX_CACHE_LINE];
    //用以记录当前需打印的作业数
    private int dataNum = 0;
    public void out()
    {
       //只要还有作业，继续打印
       while(dataNum &gt; 0)
       {
           System.out.println(&quot;打印机打印：&quot; + printData[0]);
           //把作业队列整体前移一位，并将剩下的作业数减1
           System.arraycopy(printData , 1, printData, 0, --dataNum);
       }
    }
    public void getData(String msg)
    {
       if (dataNum &gt;= MAX_CACHE_LINE)
       {
           System.out.println(&quot;输出队列已满，添加失败&quot;);
       }
       else
       {
           //把打印数据添加到队列里，已保存数据的数量加1。
           printData[dataNum++] = msg;
       }
    }
}
</code></pre><p>BetterPrinter，Output的一个实现</p>
<pre><code>public class BetterPrinter implements Output
{
    private String[] printData = new String[MAX_CACHE_LINE * 2];
    //用以记录当前需打印的作业数
    private int dataNum = 0;
    public void out()
    {
       //只要还有作业，继续打印
       while(dataNum &gt; 0)
       {
           System.out.println(&quot;高速打印机正在打印：&quot; + printData[0]);
           //把作业队列整体前移一位，并将剩下的作业数减1
           System.arraycopy(printData , 1, printData, 0, --dataNum);
       }
    }
    public void getData(String msg)
    {
       if (dataNum &gt;= MAX_CACHE_LINE * 2)
       {
           System.out.println(&quot;输出队列已满，添加失败&quot;);
       }
       else
       {
           //把打印数据添加到队列里，已保存数据的数量加1。
           printData[dataNum++] = msg;
       }
    }
}
</code></pre><p>OutputFactory，简单工厂类</p>
<pre><code>public Output getPrinterOutput(String type) {
       if (type.equalsIgnoreCase(&quot;better&quot;)) {
           return new BetterPrinter();
       } else {
           return new Printer();
       }
    }
}
</code></pre><p>Computer</p>
<pre><code>public class Computer
{
    private Output out;

    public Computer(Output out)
    {
       this.out = out;
    }
    //定义一个模拟获取字符串输入的方法
    publicvoid keyIn(String msg)
    {
       out.getData(msg);
    }
    //定义一个模拟打印的方法
    public void print()
    {
       out.out();
    }
    public static void main(String[] args)
    {
       //创建OutputFactory
       OutputFactory of = new OutputFactory();
       //将Output对象传入，创建Computer对象
       Computer c = new Computer(of.getPrinterOutput(&quot;normal&quot;));
       c.keyIn(&quot;建筑永恒之道&quot;);
       c.keyIn(&quot;建筑模式语言&quot;);
       c.print();
       c = new Computer(of.getPrinterOutput(&quot;better&quot;));
       c.keyIn(&quot;建筑永恒之道&quot;);
       c.keyIn(&quot;建筑模式语言&quot;);
       c.print();
    }
}
</code></pre><p>使用简单工厂模式的优势：让对象的调用者和对象创建过程分离，当对象调用者需要对象时，直接向工厂请求即可。从而避免了对象的调用者与对象的实现类以硬编码方式耦合，以提高系统的可维护性、可扩展性。工厂模式也有一个小小的缺陷：当产品修改时，工厂类也要做相应的修改。</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式结构中包括四种角色：<br>　　一、主题：主题是一个接口，该接口规定了具体主题需要实现的方法，比如添加、删除观察者以及通知观察者更新数据的方法。<br>　　二、观察者：观察者也是一个接口，该接口规定了具体观察者用来更新数据的方法。<br>　　三、具体主题：具体主题是一个实现主题接口的类，该类包含了会经常发生变化的数据。而且还有一个集合，该集合存放的是观察者的引用。<br>　　四：具体观察者：具体观察者是实现了观察者接口的一个类。具体观察者包含有可以存放具体主题引用的主题接口变量，以便具体观察者让具体主题将自己的引用添加到具体主题的集合中，让自己成为它的观察者，或者让这个具体主题将自己从具体主题的集合中删除，使自己不在时它的观察者。</p>
<p>观察者模式定义了对象间的一对多依赖关系，让一个或多个观察者对象观察一个主题对象。当主题对象的状态发生变化时，系统能通知所有的依赖于此对象的观察者对象，从而使得观察者对象能够自动更新。<br>在观察者模式中，被观察的对象常常也被称为目标或主题（Subject），依赖的对象被称为观察者（Observer）。</p>
<p>Observer，观察者接口：<br>观察者：观察者也是一个接口，该接口规定了具体观察者用来更新数据的方法</p>
<pre><code>public interface Observer {
    void update(Observable o, Object arg);
}
</code></pre><p>Observable，目标或主题：<br>主题：主题是一个接口，该接口规定了具体主题需要实现的方法，比如添加、删除观察者以及通知观察者更新数据的方法</p>
<pre><code>public abstract class Observable {
    // 用一个List来保存该对象上所有绑定的事件监听器
    List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;();

    // 定义一个方法，用于从该主题上注册观察者
    public void registObserver(Observer o) {
       observers.add(o);
    }

    // 定义一个方法，用于从该主题中删除观察者
    publicvoid removeObserver(Observer o) {
       observers.add(o);
    }

    // 通知该主题上注册的所有观察者
    public void notifyObservers(Object value) {
       // 遍历注册到该被观察者上的所有观察者
       for (Iterator it = observers.iterator(); it.hasNext();) {
           Observer o = (Observer) it.next();
           // 显式每个观察者的update方法
           o.update(this, value);
       }
    }
}
</code></pre><p>Product被观察类：<br>具体主题：具体主题是一个实现主题接口的类，该类包含了会经常发生变化的数据。而且还有一个集合，该集合存放的是观察者的引用。</p>
<pre><code>public class Product extends Observable {
    // 定义两个属性
    private String name;
    private double price;

    // 无参数的构造器
    public Product() {
    }

    public Product(String name, double price) {
       this.name = name;
       this.price = price;
    }

    public String getName() {
       returnname;
    }

    // 当程序调用name的setter方法来修改Product的name属性时
    // 程序自然触发该对象上注册的所有观察者
    public void setName(String name) {
       this.name = name;
       notifyObservers(name);
    }

    public double getPrice() {
       returnprice;
    }

    // 当程序调用price的setter方法来修改Product的price属性时
    // 程序自然触发该对象上注册的所有观察者
    public void setPrice(double price) {
       this.price = price;
       notifyObservers(price);
    }
}
</code></pre><p>具体观察者：具体观察者是实现了观察者接口的一个类。具体观察者包含有可以存放具体主题引用的主题接口变量，以便具体观察者让具体主题将自己的引用添加到具体主题的集合中，让自己成为它的观察者，或者让这个具体主题将自己从具体主题的集合中删除，使自己不在时它的观察者。</p>
<p>NameObserver名称观察者：</p>
<pre><code>public class NameObserver implements Observer {
    // 实现观察者必须实现的update方法
    public void update(Observable o, Object arg) {
       if (arg instanceof String) {
           // 产品名称改变值在name中
           String name = (String) arg;
           // 启动一个JFrame窗口来显示被观察对象的状态改变
           JFrame f = new JFrame(&quot;观察者&quot;);
           JLabel l = new JLabel(&quot;名称改变为：&quot; + name);
           f.add(l);
           f.pack();
           f.setVisible(true);
           System.out.println(&quot;名称观察者:&quot; + o + &quot;物品名称已经改变为: &quot; + name);
       }
    }
}
</code></pre><p>PriceObserver价格观察者：</p>
<pre><code>public class PriceObserver implements Observer {
    // 实现观察者必须实现的update方法
    public void update(Observable o, Object arg) {
       if (arg instanceof Double) {
           System.out.println(&quot;价格观察者:&quot; + o + &quot;物品价格已经改变为: &quot; + arg);
       }
    }
}
</code></pre><p>测试：</p>
<pre><code>public class Test {
    public static void main(String[] args) {
       // 创建一个被观察者对象
       Product p = new Product(&quot;电视机&quot;, 176);
       // 创建两个观察者对象
       NameObserver no = new NameObserver();
       PriceObserver po = new PriceObserver();
       // 向被观察对象上注册两个观察者对象
       p.registObserver(no);
       p.registObserver(po);
       // 程序调用setter方法来改变Product的name和price属性
       p.setName(&quot;书桌&quot;);
       p.setPrice(345f);
    }
}
</code></pre>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/03/02/性能优化/" itemprop="url">
                  性能优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-03-02T14:51:51+08:00" content="2016-03-02">
              2016-03-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/02/性能优化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/02/性能优化/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>参考自<a href="http://www.trinea.cn/android/performance/" target="_blank" rel="external">Trinea 性能优化系列总篇</a></p>
<h2 id="线程的优化"><a href="#线程的优化" class="headerlink" title="线程的优化"></a>线程的优化</h2><p>由于每次执行异步任务都去使用new Thread或者new AsynTask新建对象性能比较差，并且缺乏统一的管理，因此考虑用线程池的去管理重用线程的方案比较好。</p>
<p>Java通过Executors提供四种线程池，分别为：<br>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。<br>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。<br>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p>
<p><li>(1).CachedThreadPool </li><br>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。示例代码如下：</p>
<pre><code>ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
for (int i = 0; i &lt; 10; i++) {
    final int index = i;
    try {
        Thread.sleep(index * 1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    cachedThreadPool.execute(new Runnable() {

        @Override
        public void run() {
            System.out.println(index);
        }
    });
}
</code></pre><p>线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。</p>
<p><li>(2).FixedThreadPool </li><br>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。示例代码如下：</p>
<pre><code>ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);
for (int i = 0; i &lt; 10; i++) {
    final int index = i;
    fixedThreadPool.execute(new Runnable() {

        @Override
        public void run() {
            try {
                System.out.println(index);
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    });
}
</code></pre><p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。<br>定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()。</p>
<p><li>(3).ScheduledThreadPool </li><br>创建一个定长线程池，支持定时及周期性任务执行。延迟执行示例代码如下：</p>
<pre><code>ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);
scheduledThreadPool.schedule(new Runnable() {

    @Override
    public void run() {
        System.out.println(&quot;delay 3 seconds&quot;);
    }
}, 3, TimeUnit.SECONDS);
</code></pre><p>表示延迟3秒执行。</p>
<p>定期执行示例代码如下：</p>
<pre><code>scheduledThreadPool.scheduleAtFixedRate(new Runnable() {
    @Override
    public void run() {
        System.out.println(&quot;delay 1 seconds, and excute every 3 seconds&quot;);
    }
}, 1, 3, TimeUnit.SECONDS);
</code></pre><p>表示延迟1秒后每3秒执行一次。<br>ScheduledExecutorService比Timer更安全，功能更强大。<br>比较两者Timer缺陷主要如下:<br>1.Timer在执行定时任务时只会创建一个线程，如果存在多个任务且任务时间较长，那么其它任务并不能够准时执行。<br>2.由某个任务抛出异常，导致其余任务不能正常执行，而ScheduledExecutorService是线程池任务互不影响。<br>3.Timer执行周期任务时依赖系统时间，而ScheduledExecutorService基于时间的延迟，不会由于系统时间的改变发生执行变化。</p>
<p><li>(4).SingleThreadExecutor </li><br>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。示例代码如下：</p>
<pre><code>ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
for (int i = 0; i &lt; 10; i++) {
    final int index = i;
    singleThreadExecutor.execute(new Runnable() {

        @Override
        public void run() {
            try {
                System.out.println(index);
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    });
}
</code></pre><p>结果依次输出，相当于顺序执行各个任务。<br>现行大多数GUI程序都是单线程的。Android中单线程可用于数据库操作，文件操作，应用批量安装，应用批量删除等不适合并发但可能IO阻塞性及影响UI线程响应的操作。</p>
<h2 id="数据库的优化"><a href="#数据库的优化" class="headerlink" title="数据库的优化"></a>数据库的优化</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>数据库中索引可以帮助快速找到数据，而不用全表扫描，合适的索引可以大大提高数据库查询的效率。缺点是索引的创建和维护存在消耗，索引会占用物理空间，且随着数据量的增加而增加，对增加删除性能也会有所影响。</p>
<h3 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h3><p>Sqlite默认会为每个插入、更新操作创建一个事务，并且在每次插入、更新后立即提交。这样如果连续插入100次数据实际是创建事务-&gt;执行语句-&gt;提交这个过程被重复执行了100次。如果我们显示的创建事务-&gt;执行100条语句-&gt;提交会使得这个创建事务和提交这个过程只做一次，通过这种一次性事务可以使得性能大幅提升。尤其当数据库位于sd卡时，时间上能节省两个数量级左右。</p>
<pre><code>public void insertWithOneTransaction() {
    SQLiteDatabase db = sqliteOpenHelper.getWritableDatabase();
    // Begins a transaction
    db.beginTransaction();
    try {
        // your sqls
        for (int i = 0; i &lt; 100; i++) {
            db.insert(yourTableName, null, value);
        }

        // marks the current transaction as successful
        db.setTransactionSuccessful();
    } catch (Exception e) {
        // process it
        e.printStackTrace();
    } finally {
        // end a transaction
        db.endTransaction();
    }
}
</code></pre><h3 id="使用事务-1"><a href="#使用事务-1" class="headerlink" title="使用事务"></a>使用事务</h3><p>(1) 语句的拼接使用StringBuilder代替String<br>这个就不多说了，简单的string相加会导致创建多个临时对象消耗性能。StringBuilder的空间预分配性能好得多。如果你对字符串的长度有大致了解，如100字符左右，可以直接new StringBuilder(128)指定初始大小，减少空间不够时的再次分配。</p>
<p>(2) 查询时返回更少的结果集及更少的字段。<br>查询时只取需要的字段和结果集，更多的结果集会消耗更多的时间及内存，更多的字段会导致更多的内存消耗。</p>
<p>(3) 少用cursor.getColumnIndex<br>根据性能调优过程中的观察cursor.getColumnIndex的时间消耗跟cursor.getInt相差无几。可以在建表的时候用static变量记住某列的index，直接调用相应index而不是每次查询。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/03/02/安卓内存溢出的情形与解决方案/" itemprop="url">
                  安卓内存泄漏与解决方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-03-02T09:36:22+08:00" content="2016-03-02">
              2016-03-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/02/安卓内存溢出的情形与解决方案/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/02/安卓内存溢出的情形与解决方案/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p><img src="https://raw.githubusercontent.com/wuhanzhouguanjie/wuhanzhouguanjie.github.io/master/uploads/titanic.jpg"></p>
<h2 id="Thread造成的内存泄漏"><a href="#Thread造成的内存泄漏" class="headerlink" title="Thread造成的内存泄漏"></a>Thread造成的内存泄漏</h2><p>如下代码所示：</p>
<pre><code>public class MyActivity extends Activity {  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        new MyThread().start();  
    }

    private class MyThread extends Thread {  
        @Override  
        public void run() {  
            super.run();  
            dosomthing();  
        }  
    }
}     
</code></pre><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>假设MyThread的run函数是一个很费时的操作，当我们开启该线程后，将设备的横屏变为了竖屏,一般情况下当屏幕转换时会重新创建Activity，按照我们的想法，老的Activity应该会被销毁才对，然而事实上并非如此。<br>由于我们的线程是Activity的内部类，所以MyThread中保存了Activity的一个引用<b>（Java中，非静态内部类和匿名类都会潜在引用它们所属外部类）</b>。当MyThread的run函数没有结束时，MyThread是不会被销毁的，因此它所引用的老的Activity也不会被销毁，因此就出现了内存泄露的问题。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><li>针对非静态内部类会持有外部类引用的问题，考虑将其改为静态内部类，切断Activity对Thread的强引用。</li><br><li>在线程内部采用弱引用保存context，切断Thread对Activity的强引用。</li>

<p>改进代码如下：</p>
<pre><code>public class MyActivity extends Activity {  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        new MyThread().start();  
    }

    private static class MyThread extends Thread {  
        WeakReference&lt;MyActivity&gt; mThreadActivityRef; 
        public MyThread(ThreadAvoidActivity activity) {  
            mThreadActivityRef = new WeakReference&lt;MyActivity(activity);  
        }   
        @Override  
        public void run() {  
            super.run();  
            if (mThreadActivityRef == null)  
                return;
            if (mThreadActivityRef.get() != null)  
                mThreadActivityRef.get().dosomthing(); 
        }  
    }
}        
</code></pre><h2 id="Handler造成的内存泄漏"><a href="#Handler造成的内存泄漏" class="headerlink" title="Handler造成的内存泄漏"></a>Handler造成的内存泄漏</h2><p>如下代码所示：</p>
<pre><code>public class MyActivity extends Activity {  
    private final Handler mHandler = new Handler(){
        @override
        public void handleMessage(Message msg){

        }
    }
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  

        mHandler.postDelayed(new Runnable){
            @override
            public void run(){
                /*doSomething*/
            }
        },1000 * 60 * 10);
        finish();
    }
}
</code></pre><h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h3><p>当Android应用程序启动时，会为该应用程序的主线程创建一个Looper对象。这个Looper对象包含一个简单的消息队列Message Queue，并且能够循环的处理队列中的消息。这些消息包括大多数应用程序framework事件，例如Activity生命周期方法调用、button点击等，这些消息都会被添加到消息队列中并被逐个处理。另外，主线程的Looper对象会伴随该应用程序的整个生命周期。<br>然后，当主线程里，实例化一个Handler对象后，它就会自动与主线程Looper的消息队列关联起来。所有发送到消息队列的消息Message都会拥有一个对<b>Handler的引用</b>，所以当Looper来处理消息时，会据此回调handleMessage方法来处理消息。<br>当activity finish的时候由于该消息会一直保存在主线程的消息队列十分钟，又由于该消息持有对handler的引用，而handler又持有其外部类activity的引用，因此activity迟迟不能被回收造成内存泄漏。</p>
<h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><p>和Thread内存泄漏的解决办法一直，采用static类加弱引用的方法解决。</p>
<pre><code>public class MyActivity extends Activity {
  private static class MyHandler extends Handler {
    private final WeakReference&lt;MyActivity&gt; mActivity;
    public MyHandler(MyActivity activity) {
      mActivity = new WeakReference&lt;MyActivity&gt;(activity);
    }

    @Override
    public void handleMessage(Message msg) {
      MyActivity activity = mActivity.get();
      if (activity != null) {
        // ...
      }
    }
  }

  private final MyHandler mHandler = new MyHandler(this);

  /**
   + Instances of anonymous classes do not hold an implicit
   + reference to their outer class when they are &quot;static&quot;.
   */
  private static final Runnable sRunnable = new Runnable() {
      @Override
      public void run() { /* ... */ }
  };

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // Post a message and delay its execution for 10 minutes.
    mHandler.postDelayed(sRunnable, 1000 * 60 * 10);
    // Go back to the previous Activity.
    finish();
  }
}
</code></pre><p>最后在Activity onDestroy的时候可以进行一些清理工作。</p>
<pre><code>public void onDestroy() {  
    mHandler.removeMessages(MESSAGE_1);  
    mHandler.removeMessages(MESSAGE_2);  
    mHandler.removeMessages(MESSAGE_3);  
    mHandler.removeCallbacks(mRunnable); 

    //mHandler.removeCallbacksAndMessages(null);   
}     
</code></pre><h2 id="AsyncTask造成的内存泄漏"><a href="#AsyncTask造成的内存泄漏" class="headerlink" title="AsyncTask造成的内存泄漏"></a>AsyncTask造成的内存泄漏</h2><p>如下代码所示：</p>
<pre><code>public class MyActivity extends Activity {  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        mMyAsyncTask = new MyAsyncTask();
        mMyAsyncTask.execute();
    }

    private class MyAsyncTask extends  AsyncTask&lt;Void, Void, String&gt;{
        @Override
        protected String doInBackground(Void... params){
            return str;
        }
            @Override
        protected void onPostExecute(String result){
            ...doSomething
        }
    }
}     
</code></pre><h3 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h3><p>Android开发中，AsyncTask可以替代Thread和handler来发送请求更新ui，但实际使用中AsyncTask还是会带来很多问题的。AsyncTask提供了一个cancel(boolean)方法来取消任务，但是它并不能确保AsyncTask马上被停止，AsyncTask会一直执行, 直到doInBackground()方法执行完毕,而后执行onCancelled(Result result) 方法。</p>
<p>AsyncTask会保留一个对创建了AsyncTask的Activity的引用。如果Activity已经被销毁，AsyncTask的后台线程还在执行，它将继续在内存里保留这个引用，导致Activity无法被回收，引起内存泄露。屏幕旋转或Activity在后台被系统杀掉等情况会导致Activity的重新创建，之前运行的AsyncTask会持有一个之前Activity的引用，这个引用已经无效，这时调用onPostExecute()再去更新界面将不再生效。</p>
<p>AsyncTask可以支持并行和串行，当想要串行执行时，直接执行execute()方法，如果需要并行执行，则要执行executeOnExecutor(Executor)。</p>
<h3 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h3><p>同上面2个的解决方案类似。</p>
<pre><code>public abstract class WeakAsyncTask&lt;Params, Progress, Result, WeakTarget&gt; extends AsyncTask&lt;Params, Progress, Result&gt; { 

    protected WeakReference&lt;WeakTarget&gt; mTarget; 

    public WeakAsyncTask(WeakTarget target) { 
        mTarget = new WeakReference&lt;WeakTarget&gt;(target); 
    } 

    @Override 
    protected final void onPreExecute() { 
        final WeakTarget target = mTarget.get(); 
        if (target != null) { 
            this.onPreExecute(target); 
        } 
    } 

    @Override 
    protected final Result doInBackground(Params... params) { 
        final WeakTarget target = mTarget.get(); 
        if (target != null) { 
            return this.doInBackground(target, params); 
        } else { 
            return null; 
        } 
    } 

    @Override 
    protected final void onPostExecute(Result result) { 
        final WeakTarget target = mTarget.get(); 
        if (target != null) { 
            this.onPostExecute(target, result); 
        } 
    } 

    protected void onPreExecute(WeakTarget target) { 
        // Nodefaultaction 
    } 

    protected abstract Result doInBackground(WeakTarget target, 
            Params... params); 

    protected void onPostExecute(WeakTarget target, Result result) { 
        // Nodefaultaction 
    } 
} 
</code></pre><h2 id="其它的内存泄漏情况"><a href="#其它的内存泄漏情况" class="headerlink" title="其它的内存泄漏情况"></a>其它的内存泄漏情况</h2><h3 id="原因-3"><a href="#原因-3" class="headerlink" title="原因"></a>原因</h3><li>1.集合中对象没清理造成的内存泄露</li><br><li>2.资源对象没关闭造成的内存泄露(Cursor，File等)</li><br><li>3.Bitmap对象在不使用时,我们应该先调用recycle()释放内存，然后才它设置为null。</li><br><li>4.注册某个对象后未反注册（广播，观察者等）</li>

<h3 id="解决办法-3"><a href="#解决办法-3" class="headerlink" title="解决办法"></a>解决办法</h3><p>对于一些反注册和清理工作还是要在编码的时候细心，而例如一些handler,Thread造成的内存问题通过合理的修改对象引用类型来解决。</p>
<p>引用分为四种级别，这四种级别由高到低依次为：强引用&gt;软引用&gt;弱引用&gt;虚引用。<br>强引用（strong reference）<br>如：Object object=new Object（），object就是一个强引用了。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。<br>软引用（SoftReference）<br>只有内存不够时才回收,常用于缓存；当内存达到一个阀值，GC就会去回收它；<br>弱引用（WeakReference）<br>弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。<br>虚引用（PhantomReference）<br>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。  </p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/2016/03/01/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-03-01T14:21:16+08:00" content="2016-03-01">
              2016-03-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/hexo/" itemprop="url" rel="index">
                    <span itemprop="name">hexo</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/01/hello-world/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/01/hello-world/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  

 </div>

        

        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/uploads/avatar.jpg" alt="zgj" itemprop="image"/>
          <p class="site-author-name" itemprop="name">zgj</p>
        </div>
        <p class="site-description motion-element" itemprop="description">No King rules forervr</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">3</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">3</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/wuhanzhouguanjie" target="_blank">
                  <i class="fa fa-github"></i> github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/2609341065/home?topnav=1&wvr=6" target="_blank">
                  <i class="fa fa-weibo"></i> weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/18sui-47-9" target="_blank">
                  <i class="fa fa-zhihu"></i> zhihu
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zgj</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zhouguanjie"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     


    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/MathJax.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/config/TeX-AMS-MML_HTMLorMML.js"></script>
  


  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
